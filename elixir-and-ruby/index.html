<!DOCTYPE html>
<html>
  <head>
    <title>Elixir and Ruby</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3, h4 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      h1 {
        margin-top: 10px;
        margin-bottom: 5px;
      }
      h2, h3, h4 {
        margin-top: 7px;
        margin-bottom: 0;
      }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .column-left{ float: left; width: 33%; }
      .column-right{ float: right; width: 33%; }
      .column-center{ display: inline-block; width: 33%; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      .remark-slide-content code {
        font-size: 0.8em;
      }
      .remark-slide-content pre code {
        font-size: 0.8em;
        padding: 15px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Elixir and Ruby

.pull-left[
![Elixir](elixir-logo.png)

http://elixir-lang.org
]
.pull-right[
![Ruby](ruby-logo.png)

http://ruby-lang.org
]

---

# What is Elixir?

* Functional language built on the Erlang VM and OTP
* With Erlang comes a host of powerful stuff (fault tolerance, distributed processing, etc)
* Syntax and conventions heavily influenced by Ruby
* If you know Ruby, you know quite a bit of Elixir already
* Created by José Valim (Devise, Rails) to take advantage of Erlang's existing capabilities, with a nicer syntax and modern set of tools

.pull-left[
### Elixir
```elixir
iex> IO.puts "Hello, Elixir!"
Hello, Elixir!
:ok

iex> ["One", :two, 3]
["One", :two, 3]
```
]

.pull-right[
### Ruby
```ruby
irb> puts "Hello, Ruby!"
Hello, Ruby!
=> nil

irb> ["One", :two, 3]
 => ["One", :two, 3]
```
]

???

* Erlang made at Ericsson for telephony switches/exchanges
 * Highly distributed
 * High availability
 * Claiming 9 Nine's in one product (~31.5ms per year of downtime)
* Erlang philosophy "Let It Crash", designed to handle failures more declaritively
 * Can avoid handling errors and exceptions in many cases, code w/less complexity
* OTP: Erlang standard library, Open Telecom Platform
* Calls into Erlang have no additional overhead, everything is compiled to BEAM bytecode
* You should totally check out that powerful stuff!  Won't be talking about it here.

---

# Some Similarities

* Open Source
* High-level, dynamic typing, strong typing
* Can be run interpreted for use in scripting
* REPL
* Tools, package management built in to language distribution
* Many parts of the syntax are identical or nearly so
* Friendly communities

# Some Differences

* Ruby can be written in many ways, but typically object-oriented
* Elixir is functional, data structures are immutable!
* In Elixir, state is achieved using Actors
* Elixir (and Erlang) have no "traditional" threading
* Being built on Erlang, Elixir has first-class support for running in distributed environments

???

Similarities
* e.g. Unit tests are run scripted, not important to compile ahead of time
* MINASWAN -> JINASWAN

Differences
* XXX Actor model?
* All concurrent processing is handled by the VM, using light-weight processes
* VM doesn't care where a process is, can be local or a remote machine

---

# Code!

.pull-left[
### Elixir
```elixir
iex> [1, 2.1, 2.1e2, 0x2F, 0b0101, 10_000]
[1, 2.1, 210.0, 47, 5, 10000]

iex> [true, false, :atom, :"stringy-atom"]
[true, false, :atom, :"stringy-atom"]

iex> "Iñtërnâtiônàlizætiøn"
"Iñtërnâtiônàlizætiøn"

iex> String.upcase("Iñtërnâtiônàlizætiøn")
"IÑTËRNÂTIÔNÀLIZÆTIØN"

iex> String.upcase("weiß")
"WEISS"

iex> foo = "Interpolation"
iex> "String #{foo}"
"String Interpolation"

irb> 'Single'
'Single'

iex> [83, 105, 110, 103, 108, 101]
'Single'
```
]

.pull-right[
### Ruby
```ruby
irb> [1, 2.1, 2.1e2, 0x2F, 0b0101, 10_000]
 => [1, 2.1, 210.0, 47, 5, 10000]

irb> [true, false, :symb, :"stringy-symb"]
 => [true, false, :symb, :"stringy-symb"]

irb> "Iñtërnâtiônàlizætiøn"
 => "Iñtërnâtiônàlizætiøn"

irb> "Iñtërnâtiônàlizætiøn".upcase
 => "IñTëRNâTIôNàLIZæTIøN"

irb> "weiß".upcase
 => "WEIß"

irb> foo = "Interpolation"
irb> "String #{foo}"
 => "String Interpolation"

irb> 'Single'
 => "Single"

irb> [83, 105, 110, 103, 108, 101]
 => [83, 105, 110, 103, 108, 101]
```
]

???

* Atoms in Erlang very similar to Ruby, only created once
 * Erlang they are not GC'd
 * Ruby as of 2.2 they can be
* Elixir has better built-in support for Unicode
 * Ruby needs [unicode-utils](http://unicode-utils.rubyforge.org)
* Char lists are not strings!

---

# Code!

.pull-left[
### Elixir
```elixir
iex> {"Tuple", "of", "Strings"}
{"Tuple", "of", "Strings"}

iex> ["List", "of", "Strings"]
["List", "of", "Strings"]

iex> [keyword: "lists", are: "fun"]
[keyword: "lists", are: "fun"]

iex> [{:just, "lists"}, {:of, "tuples"}]
[just: "lists", of: "tuples"]

iex> %{:map => "2", "key" => :varies}
%{:map => "2", "key" => :varies}
```
]

.pull-right[
### Ruby
```ruby
irb> # No tuples, but a list
...> # is pretty close

irb> ["List", "of", "Strings"]
 => ["List", "of", "Strings"]

irb> {hash: "with", only: "symbol keys"}
 => {:hash=>"with", :only=>"symbol keys"}

irb> # No real Ruby equivalent
...> # that I know of

irb> {hash: "with", "!" => :x, 4 => "key"}
 => {:hash=>"with", "!"=>:x, 4=>"key"}
```
]

???

* Tuples - not collections, meant for storing multiple things together
* Lists - internally they are linked lists

---

# More Code!

.pull-left[
### Elixir
```elixir
iex> f = fn x -> x + 1 end
iex> f.(2)
3

iex> defmodule Foo do
...>   def bar(x), do: x + 2
...> end
iex> Foo.bar(10)
12

iex> # Sorry!
iex> # No!
iex> # Classes!

iex> defmodule Data do
...>   defstruct x: nil, y: 2, z: "zee"
...> end
iex> d = %Data{x: 25, z: "why"}
%Data{x: 25, y: 2, z: "why"}
iex> d.x
25
```
]

.pull-right[
### Ruby
```ruby
irb> f = ->(x) { x + 1 }
irb> f.(2)
 => 3

irb> module Foo
...>   def self.bar(x) x + 2 end
...> end
irb> Foo.bar(10)
 => 12

irb> class Baz
...>   def quux(x) x - 1 end
...> end

irb> Data = Struct.new(:x, :y, :z)


irb> d = Data.new(25, 2, "why")
 => #<struct Data x=25, y=2, z="why">
irb> d.x
 => 25
```
]

???

* Modules are just bags of functions
* Can't use `def` outside of a module, sugar to assign the function to that name w/in module
* Tuples - not collections, meant for storing multiple things together
* Lists - internally they are linked lists

---

# Nifty Code!

* Pipelines
* Pattern Matching
 * Using maps/strings,tuples
* Binary decoding

---

# Tools

If you like rbenv or rvm, asdf (https://github.com/HashNuke/asdf) is a simple version manager for Elixir (and Erlang, Ruby, even Node).

.column-left[
### Need
* Build/tasks
* Package mgmt
* Dependency mgmt
]

.column-center[
### Elixir
* mix
* mix
* mix+hex.pm
]

.column-right[
### Ruby
* Rake
* Bundler
* Bundler+RubyGems.org
]

???

* Like Bundler and its Rake tasks, mix can:
 * create new projects
 * manage library dependencies
 * publish releases to hex.pm

---

# More Stuff
### (You should totally check out on your own)

* Process supervision, GenServers, Actors
 * Building blocks of Erlang's fault-tolerance and distributed processing
* Macros, macros, macros

???

* Macros let you manipulate the code that has been passed to them, change how it's evalulated, etc.
* Macros are how metaprogramming works in Elixir
* A large amount of the language itself is defined as macros
 * most keywords
 * most operators

---

# Try It!


    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      remark.create({
        highlightStyle: 'monokai',
        highlightLines: true
      });
    </script>
  </body>
</html>
